<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta property="og:site_name" content="Lettier">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Triforce Overload, Sierpinski Pyramids by David Lettier">
    <meta property="og:image" content="https://lettier.github.io/images/2016-02-29-triforce-overload-sierpinski-pyramids/jumbotron_image.jpg">
    <meta property="og:url" content="https://lettier.github.io/posts/2016-02-29-triforce-overload-sierpinski-pyramids.html">
    <meta property="og:description" content="Using only the WebGL, we implement an explorable environment containing two 3D Sierpinski tetrahedrons lit by per fragment lighting.">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="David Lettier">
    <meta name="description" content="Using only the WebGL, we implement an explorable environment containing two 3D Sierpinski tetrahedrons lit by per fragment lighting.">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="../css/pandoc.css">
    <link rel="stylesheet" type="text/css" href="../css/default.css">
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="RSS">
    
      <title>Triforce Overload, Sierpinski Pyramids by David Lettier</title>
    
  </head>
  <body>
    <div id="top"></div>
    <nav class="navbar navbar-inverse navbar-transparent navbar-fixed-top">
      <div class="container-fluid navbar-container">
        <ul class="nav navbar-nav nav-left">
          <!--
          <li class="nav-link"><a href="/">Home</a></li>
          <li class="nav-link"><a href="/posts.html">Posts</a></li>
          -->
          <li>
            <div class="nav-icon-container">
              <a href="../" title="Home">
                <div>
                  <i class="fa fa-home nav-icon"></i>
                </div>
                <div class="nav-icon-dot">
                </div>
              </a>
            </div>
          </li>
          <li>
            <div class="nav-icon-container">
              <a href="../rss.xml" title="RSS" type="application/rss+xml" target="_blank">
                <div>
                  <i class="fa fa-rss nav-icon"></i>
                </div>
                <div class="nav-icon-dot">
                </div>
              </a>
            </div>
          </li>
          <li>
            <div class="nav-icon-container">
              <a href="../posts.html" title="Posts">
                <div>
                  <i class="fa fa-th-large nav-icon shaker"></i>
                </div>
                <div class="nav-icon-dot">
                </div>
              </a>
            </div>
          </li>
        </ul>
        <div class="nav-right">
          <!--
          <a href="http://www.lettier.com/" title="Lettier.com">
            <div class="lettier-icon">
              <img src="/images/logo.svg" width="30" height="30" alt="Lettier.com" class="lettier-icon-img">
            </div>
          </a>
          -->
          <div class="nav-icon-container">
            <a href="http://www.lettier.com/" title="Lettier.com">
              <div class="lettier-icon">
                <img src="../images/logo.svg" width="30" height="30" alt="Lettier.com" class="lettier-icon-img">
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
          <!--
          <a href="https://www.github.com/lettier" title="Github">
            <i class="fa fa-github nav-icon"></i>
          </a>
          -->
          <div class="nav-icon-container">
            <a href="https://www.github.com/lettier" title="Github">
              <div>
                <i class="fa fa-github nav-icon"></i>
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
          <!--
          <a href="https://www.linkedin.com/in/lettier" title="LinkedIn">
            <i class="fa fa-linkedin nav-icon"></i>
          </a>
          -->
          <div class="nav-icon-container">
            <a href="https://www.linkedin.com/in/lettier" title="LinkedIn">
              <div>
                <i class="fa fa-linkedin nav-icon"></i>
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
          <!--
          <a href="https://stackoverflow.com/users/3838674/lettier" title="Stack Overflow">
            <i class="fa fa-stack-overflow nav-icon"></i>
          </a>
          <div class="nav-icon-container">
            <a href="https://stackoverflow.com/users/3838674/lettier" title="Stack Overflow">
              <div>
                <i class="fa fa-stack-overflow nav-icon"></i>
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
          -->
          <!--
          <a href="https://www.hackerrank.com/lettier" title="HackerRank">
            <i class="fa fa-trophy nav-icon nav-icon-second-last"></i>
          </a>
          -->
          <div class="nav-icon-container nav-icon-container-second-last">
            <a href="https://www.hackerrank.com/lettier" title="HackerRank">
              <div>
                <i class="fa fa-trophy nav-icon nav-icon-second-last"></i>
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
          <!--
          <a href="https://www.behance.net/dlettier" title="Behance">
            <i class="fa fa-behance nav-icon nav-icon-last"></i>
          </a>
          -->
          <div class="nav-icon-container nav-icon-container-last">
            <a href="https://www.behance.net/dlettier" title="Behance">
              <div>
                <i class="fa fa-behance nav-icon"></i>
              </div>
              <div class="nav-icon-dot">
              </div>
            </a>
          </div>
        </div>
      </div>
    </nav>
    <div class="jumbotron" style="background-image: url('/images/2016-02-29-triforce-overload-sierpinski-pyramids/jumbotron_image.jpg');">
      <div class="container vertical-center">
        <div class="jumbotron-text">
          <span class="jumbotron-text-background">
            
              Triforce Overload, Sierpinski Pyramids
            
          </span>
        </div>
      </div>
    </div>
    <div class="container page-container">
      <div class="post-header">
  <div class="display-left">
  </div>
  <div class="display-right date-author">
    <p>2016/02/29 &nbsp; <i class="fa fa-calendar"></i></p>
    
      <p>David Lettier &nbsp; <i class="fa fa-user"></i></p>
    
  </div>
</div>
<div class="post-body">
  <blockquote>
<p>The Sierpinski tetrahedron or tetrix is the three-dimensional analogue of the Sierpinski triangle, formed by repeatedly shrinking a regular tetrahedron to one half its original height, putting together four copies of this tetrahedron with corners touching, and then repeating the process.</p>
<footer>
<a href="https://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinski triangle, Wikipedia, the free encyclopedia</a>
</footer>
</blockquote>
<p>The code for this project can be found <a href="https://github.com/lettier/sierpinski">here</a> with the playable version being found <a href="http://www.lettier.com/sierpinski/">here</a>.</p>
<p>Our goal is to produce 3D rotating Sierpinski Pyramids using JavaScript and WebGL. The user will be able to control the amount of subdivisions. As an added bonus, we’ll implement a realistic lighting system to render our pyramids.</p>
<h1 id="boilerplate">Boilerplate</h1>
<p>Everything starts with the HTML canvas element. This will display each frame buffer as it is rendered.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Create and add the canvas that will be &quot;painted&quot; on or rather rendered to by WebGL.</span>

canvas        <span class="op">=</span> <span class="va">document</span>.<span class="at">createElement</span>( <span class="st">&quot;canvas&quot;</span> )<span class="op">;</span>
<span class="va">canvas</span>.<span class="at">id</span>     <span class="op">=</span> <span class="st">&quot;webgl_canvas&quot;</span><span class="op">;</span>
<span class="va">canvas</span>.<span class="at">width</span>  <span class="op">=</span> <span class="va">window</span>.<span class="at">innerWidth</span><span class="op">;</span>
<span class="va">canvas</span>.<span class="at">height</span> <span class="op">=</span> <span class="va">window</span>.<span class="at">innerHeight</span><span class="op">;</span>
<span class="va">document</span>.<span class="va">body</span>.<span class="at">appendChild</span>( canvas )<span class="op">;</span></code></pre></div>
<p>After the canvas comes initialization of the WebGL context where we specify the view-port width and height. It is here that we test if the user’s browser supports WebGL.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">initGL</span>( canvas ) <span class="op">{</span>
  <span class="cf">try</span> <span class="op">{</span>
    gl <span class="op">=</span> <span class="va">canvas</span>.<span class="at">getContext</span>( <span class="st">&quot;webgl&quot;</span> ) <span class="op">||</span> <span class="va">canvas</span>.<span class="at">getContext</span>( <span class="st">&quot;experimental-webgl&quot;</span> )<span class="op">;</span>
    <span class="va">gl</span>.<span class="at">viewportWidth</span>  <span class="op">=</span> <span class="va">canvas</span>.<span class="at">width</span><span class="op">;</span>
    <span class="va">gl</span>.<span class="at">viewportHeight</span> <span class="op">=</span> <span class="va">canvas</span>.<span class="at">height</span><span class="op">;</span>
  <span class="op">}</span> <span class="cf">catch</span> ( error ) <span class="op">{</span>
    <span class="co">// Browser cannot initialize a WebGL context.</span>
    <span class="va">window</span>.<span class="va">location</span>.<span class="at">assign</span>( <span class="st">&quot;http://get.webgl.org/&quot;</span> )<span class="op">;</span>
  <span class="op">}</span>
  <span class="cf">if</span> ( <span class="op">!</span>gl ) <span class="op">{</span>
    <span class="co">// Browser cannot initialize a WebGL context.</span>
    <span class="va">window</span>.<span class="va">location</span>.<span class="at">assign</span>( <span class="st">&quot;http://get.webgl.org/&quot;</span> )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Next we need to gather, compile, and link the vertex and fragment shaders that process the vertices, normals, and colors. Once the shaders are in place, we must acquire indexes to their internal data structures. These include the vertex position, normal, and color attributes as well as the projection matrix, normal matrix, and the model-view matrix. For the lighting model, we will also need the ambient color and the point light location and color.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">initShaders</span>( ) <span class="op">{</span>
 <span class="kw">var</span> fragmentShader <span class="op">=</span> <span class="at">getShader</span>( gl<span class="op">,</span> <span class="st">&quot;shader-fs&quot;</span> )<span class="op">;</span>
 <span class="kw">var</span> vertexShader   <span class="op">=</span> <span class="at">getShader</span>( gl<span class="op">,</span> <span class="st">&quot;shader-vs&quot;</span> )<span class="op">;</span>

 shaderProgram <span class="op">=</span> <span class="va">gl</span>.<span class="at">createProgram</span>( )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">attachShader</span>( shaderProgram<span class="op">,</span> vertexShader )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">attachShader</span>( shaderProgram<span class="op">,</span> fragmentShader )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">linkProgram</span>( shaderProgram )<span class="op">;</span>

 <span class="cf">if</span> ( <span class="op">!</span><span class="va">gl</span>.<span class="at">getProgramParameter</span>( shaderProgram<span class="op">,</span> <span class="va">gl</span>.<span class="at">LINK_STATUS</span> ) ) <span class="op">{</span>
  <span class="va">console</span>.<span class="at">error</span>( <span class="st">&quot;Could not initialize shaders.&quot;</span> )<span class="op">;</span>
 <span class="op">}</span>

 <span class="va">gl</span>.<span class="at">useProgram</span>( shaderProgram )<span class="op">;</span>

 <span class="co">// Acquire handles to shader program variables in order to pass data to the shaders.</span>

 <span class="va">shaderProgram</span>.<span class="at">vertexPositionAttribute</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getAttribLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;aVertexPosition&quot;</span> )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">enableVertexAttribArray</span>( <span class="va">shaderProgram</span>.<span class="at">vertexPositionAttribute</span> )<span class="op">;</span>

 <span class="va">shaderProgram</span>.<span class="at">vertexColorAttribute</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getAttribLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;aVertexColor&quot;</span> )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">enableVertexAttribArray</span>( <span class="va">shaderProgram</span>.<span class="at">vertexColorAttribute</span> )<span class="op">;</span>

 <span class="va">shaderProgram</span>.<span class="at">vertexNormalAttribute</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getAttribLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;aVertexNormal&quot;</span> )<span class="op">;</span>
 <span class="va">gl</span>.<span class="at">enableVertexAttribArray</span>( <span class="va">shaderProgram</span>.<span class="at">vertexNormalAttribute</span> )<span class="op">;</span>

 <span class="va">shaderProgram</span>.<span class="at">pMatrixUniform</span>  <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uPMatrix&quot;</span>  )<span class="op">;</span>
 <span class="va">shaderProgram</span>.<span class="at">mvMatrixUniform</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uMVMatrix&quot;</span> )<span class="op">;</span>
 <span class="va">shaderProgram</span>.<span class="at">nMatrixUniform</span>  <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uNMatrix&quot;</span>  )<span class="op">;</span>

 <span class="va">shaderProgram</span>.<span class="at">ambientColorUniform</span>       <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uAmbientColor&quot;</span>       )<span class="op">;</span>
 <span class="va">shaderProgram</span>.<span class="at">pointLightLocationUniform</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uPointLightLocation&quot;</span> )<span class="op">;</span>
 <span class="va">shaderProgram</span>.<span class="at">pointLightColorUniform</span>    <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uPointLightColor&quot;</span>    )<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>There will be mouse and keyboard controls so we’ll need to setup event handling. Camera keys will be <code>w</code>, <code>s</code>, <code>a</code>, and <code>d</code> for forward, back, left, and right respectively. We’ll also use <code>m</code> to toggle on/off the moving of the camera.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// ...</span>

<span class="va">window</span>.<span class="at">onkeydown</span> <span class="op">=</span> <span class="kw">function</span> ( event ) <span class="op">{</span>
  <span class="cf">switch</span> ( <span class="va">event</span>.<span class="at">keyCode</span> ) <span class="op">{</span>
    <span class="cf">case</span> <span class="dv">87</span><span class="op">:</span> <span class="co">// Forward W</span>
      camera_keys[ <span class="dv">0</span> ] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">83</span><span class="op">:</span> <span class="co">// Backward S</span>
      camera_keys[ <span class="dv">1</span> ] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">65</span><span class="op">:</span> <span class="co">// Left A</span>
      camera_keys[ <span class="dv">2</span> ] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">68</span><span class="op">:</span> <span class="co">// Right D</span>
      camera_keys[ <span class="dv">3</span> ] <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="dt">default</span><span class="op">:</span>
      <span class="cf">break</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">};</span>
<span class="va">window</span>.<span class="at">onkeyup</span> <span class="op">=</span> <span class="kw">function</span> ( event ) <span class="op">{</span>
  <span class="cf">switch</span> ( <span class="va">event</span>.<span class="at">keyCode</span> ) <span class="op">{</span>
    <span class="cf">case</span> <span class="dv">87</span><span class="op">:</span> <span class="co">// Forward W</span>
      camera_keys[ <span class="dv">0</span> ] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">83</span><span class="op">:</span> <span class="co">// Backward S</span>
      camera_keys[ <span class="dv">1</span> ] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">65</span><span class="op">:</span> <span class="co">// Left A</span>
      camera_keys[ <span class="dv">2</span> ] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">68</span><span class="op">:</span> <span class="co">// Right D</span>
      camera_keys[ <span class="dv">3</span> ] <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
      <span class="cf">break</span><span class="op">;</span>
    <span class="cf">case</span> <span class="dv">77</span><span class="op">:</span> <span class="co">// Use Controls M</span>
      use_controls <span class="op">=</span> <span class="op">!</span>use_controls<span class="op">;</span>
      <span class="cf">if</span> ( use_controls ) <span class="op">{</span>
        <span class="va">canvas</span>.<span class="at">requestPointerLock</span>( )<span class="op">;</span>
        <span class="va">document</span>.<span class="at">addEventListener</span>( <span class="st">&quot;mousemove&quot;</span><span class="op">,</span> mouse_move<span class="op">,</span> <span class="kw">false</span> )<span class="op">;</span>
        <span class="va">document</span>.<span class="at">addEventListener</span>( <span class="st">&quot;mouseup&quot;</span><span class="op">,</span> mouse_button_up<span class="op">,</span> <span class="kw">false</span> )<span class="op">;</span>
      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
        <span class="va">document</span>.<span class="at">exitPointerLock</span>( )<span class="op">;</span>
        <span class="va">document</span>.<span class="at">removeEventListener</span>( <span class="st">&quot;mousemove&quot;</span><span class="op">,</span> mouse_move<span class="op">,</span> <span class="kw">false</span> )<span class="op">;</span>
        <span class="va">document</span>.<span class="at">removeEventListener</span>( <span class="st">&quot;mouseup&quot;</span><span class="op">,</span> mouse_button_up<span class="op">,</span> <span class="kw">false</span> )<span class="op">;</span>
      <span class="op">}</span>
    <span class="dt">default</span><span class="op">:</span>
      <span class="cf">break</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">};</span>

<span class="co">// ...</span></code></pre></div>
<h1 id="the-tetrahedron">The Tetrahedron</h1>
<p>Let us begin by defining the initial tetrahedron that will be recursively subdivided by the user. Increasing or decreasing <code>r</code> adjusts the overall size of the pyramid. We’ll center it at the origin which makes affine transformations convenient. For a greater aesthetic, we will color the vertices. These vertex colors will be subdivided along with the pyramid.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Dimension of the Sierpinski tetrahedron.</span>

<span class="kw">var</span> r <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>

<span class="co">// The main points of the Sierpinski tetrahedron.</span>

<span class="kw">var</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>
<span class="kw">var</span> b <span class="op">=</span> r<span class="op">;</span>
<span class="kw">var</span> c <span class="op">=</span> b <span class="op">*</span> <span class="va">Math</span>.<span class="at">sqrt</span>( <span class="dv">2</span> ) <span class="op">*</span> <span class="fl">2.0</span> / <span class="fl">3.0</span><span class="op">;</span>
<span class="kw">var</span> d <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> b / <span class="fl">3.0</span><span class="op">;</span>
<span class="kw">var</span> e <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> b <span class="op">*</span> <span class="va">Math</span>.<span class="at">sqrt</span>( <span class="dv">2</span> ) / <span class="fl">3.0</span><span class="op">;</span>
<span class="kw">var</span> f <span class="op">=</span> b <span class="op">*</span> <span class="va">Math</span>.<span class="at">sqrt</span>( <span class="dv">2</span> ) / <span class="va">Math</span>.<span class="at">sqrt</span>( <span class="dv">3</span> )<span class="op">;</span>
<span class="kw">var</span> g <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="op">*</span> f<span class="op">;</span>

<span class="kw">var</span> point_one   <span class="op">=</span> [ a<span class="op">,</span> b<span class="op">,</span> a ]<span class="op">;</span>
<span class="kw">var</span> point_two   <span class="op">=</span> [ c<span class="op">,</span> d<span class="op">,</span> a ]<span class="op">;</span>
<span class="kw">var</span> point_three <span class="op">=</span> [ e<span class="op">,</span> d<span class="op">,</span> f ]<span class="op">;</span>
<span class="kw">var</span> point_four  <span class="op">=</span> [ e<span class="op">,</span> d<span class="op">,</span> g ]<span class="op">;</span>

<span class="co">// Vertex colors of the four main points of the Sierpinski tetrahedron/pyramid.</span>

<span class="kw">var</span> color_one   <span class="op">=</span> [ <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span> ]<span class="op">;</span>
<span class="kw">var</span> color_two   <span class="op">=</span> [ <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span> ]<span class="op">;</span>
<span class="kw">var</span> color_three <span class="op">=</span> [ <span class="fl">0.0</span><span class="op">,</span> <span class="fl">0.0</span><span class="op">,</span> <span class="fl">1.0</span> ]<span class="op">;</span>
<span class="kw">var</span> color_four  <span class="op">=</span> [ <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">1.0</span> ]<span class="op">;</span></code></pre></div>
<p>With the pyramid defined, we need to bind and fill the vertex, normal and color buffers. We will need the normals later on during the lighting calculations.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Create the vertex buffer and bind it getting it ready to</span>
<span class="co">// read in the vertices to the tetrahedron/pyramid.</span>

pyramidVertexPositionBuffer <span class="op">=</span> <span class="va">gl</span>.<span class="at">createBuffer</span>( )<span class="op">;</span>
<span class="va">gl</span>.<span class="at">bindBuffer</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> pyramidVertexPositionBuffer )<span class="op">;</span>

<span class="co">// Bind and fill the pyramid vertices.</span>

<span class="va">gl</span>.<span class="at">bufferData</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> <span class="kw">new</span> <span class="at">Float32Array</span>( vertices )<span class="op">,</span> <span class="va">gl</span>.<span class="at">STATIC_DRAW</span> )<span class="op">;</span>
<span class="va">pyramidVertexPositionBuffer</span>.<span class="at">itemSize</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="va">pyramidVertexPositionBuffer</span>.<span class="at">numItems</span> <span class="op">=</span> <span class="va">vertices</span>.<span class="at">length</span> / <span class="dv">3</span><span class="op">;</span>

<span class="co">// Bind and fill the pyramid vertex normals.</span>

pyramidVertexNormalBuffer <span class="op">=</span> <span class="va">gl</span>.<span class="at">createBuffer</span>( )<span class="op">;</span>
<span class="va">gl</span>.<span class="at">bindBuffer</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> pyramidVertexNormalBuffer )<span class="op">;</span>
<span class="va">gl</span>.<span class="at">bufferData</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> <span class="kw">new</span> <span class="at">Float32Array</span>( vertex_normals )<span class="op">,</span> <span class="va">gl</span>.<span class="at">STATIC_DRAW</span> )<span class="op">;</span>
<span class="va">pyramidVertexNormalBuffer</span>.<span class="at">itemSize</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>
<span class="va">pyramidVertexNormalBuffer</span>.<span class="at">numItems</span> <span class="op">=</span> <span class="va">vertex_normals</span>.<span class="at">length</span> / <span class="dv">3</span><span class="op">;</span>

<span class="co">// Bind and fill the pyramid vertex colors.</span>

pyramidVertexColorBuffer <span class="op">=</span> <span class="va">gl</span>.<span class="at">createBuffer</span>( )<span class="op">;</span>
<span class="va">gl</span>.<span class="at">bindBuffer</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> pyramidVertexColorBuffer )<span class="op">;</span>
<span class="va">gl</span>.<span class="at">bufferData</span>( <span class="va">gl</span>.<span class="at">ARRAY_BUFFER</span><span class="op">,</span> <span class="kw">new</span> <span class="at">Float32Array</span>( vertex_colors )<span class="op">,</span> <span class="va">gl</span>.<span class="at">STATIC_DRAW</span> )<span class="op">;</span>
<span class="va">pyramidVertexColorBuffer</span>.<span class="at">itemSize</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>
<span class="va">pyramidVertexColorBuffer</span>.<span class="at">numItems</span> <span class="op">=</span> <span class="va">vertex_colors</span>.<span class="at">length</span> / <span class="dv">4</span><span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/tetra_four_view.png" alt="Single Tetrahedron (Pyramid)" class="post-img post-img-fill" />
<p class="caption">Single Tetrahedron (Pyramid)</p>
</div>
<h1 id="algorithm">Algorithm</h1>
<p>The algorithm revolves around finding the midpoint. There are six midpoints we must find for each pyramid. Three for the edges leading to the pinnacle and three for the edges that form the base.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Find the midpoints to all of the edges of this pyramid/tetrahedron.</span>

<span class="kw">var</span> p1_p2 <span class="op">=</span> <span class="at">midpoint</span>( p1<span class="op">,</span> p2 )<span class="op">;</span>
<span class="kw">var</span> p1_p3 <span class="op">=</span> <span class="at">midpoint</span>( p1<span class="op">,</span> p3 )<span class="op">;</span>
<span class="kw">var</span> p1_p4 <span class="op">=</span> <span class="at">midpoint</span>( p1<span class="op">,</span> p4 )<span class="op">;</span>
<span class="kw">var</span> p2_p3 <span class="op">=</span> <span class="at">midpoint</span>( p2<span class="op">,</span> p3 )<span class="op">;</span>
<span class="kw">var</span> p2_p4 <span class="op">=</span> <span class="at">midpoint</span>( p2<span class="op">,</span> p4 )<span class="op">;</span>
<span class="kw">var</span> p3_p4 <span class="op">=</span> <span class="at">midpoint</span>( p3<span class="op">,</span> p4 )<span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/tetra_sub.png" alt="Six Midpoints" class="post-img post-img-fill" />
<p class="caption">Six Midpoints</p>
</div>
<p>There are an additional six midpoints to find for the four colors (one for each vertex making up the pyramid).</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Subdivide the vertex colors as well--similar to subdividing the edges.</span>

<span class="kw">var</span> c1_c2 <span class="op">=</span> <span class="at">midpoint</span>( c1<span class="op">,</span> c2 )<span class="op">;</span>
<span class="kw">var</span> c1_c3 <span class="op">=</span> <span class="at">midpoint</span>( c1<span class="op">,</span> c3 )<span class="op">;</span>
<span class="kw">var</span> c1_c4 <span class="op">=</span> <span class="at">midpoint</span>( c1<span class="op">,</span> c4 )<span class="op">;</span>
<span class="kw">var</span> c2_c3 <span class="op">=</span> <span class="at">midpoint</span>( c2<span class="op">,</span> c3 )<span class="op">;</span>
<span class="kw">var</span> c2_c4 <span class="op">=</span> <span class="at">midpoint</span>( c2<span class="op">,</span> c4 )<span class="op">;</span>
<span class="kw">var</span> c3_c4 <span class="op">=</span> <span class="at">midpoint</span>( c3<span class="op">,</span> c4 )<span class="op">;</span></code></pre></div>
<p>Once the midpoints are found, we recursively call <code>divide_tetrahedron</code> for each new set of four points and colors. There are a total of four sets of four points and four colors. In other words, before subdivision we have four triangles and afterwards we have 16 making up the four new pyramids. One pyramid is located on top with three located on the bottom.</p>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/tetra_four.png" alt="Four New Pyramids" class="post-img post-img-fill" />
<p class="caption">Four New Pyramids</p>
</div>
<p>For more subdivisions, we’ll recursively call <code>divide_tetrahedron</code> on each of the four pyramids. We can do this as many times as our machine hardware will allow for but we’ll cap the subdivisions at seven.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// ...</span>

  <span class="va">up_button</span>.<span class="at">onclick</span> <span class="op">=</span> <span class="kw">function</span> ( )
  <span class="op">{</span>
    <span class="cf">if</span> ( subdivide_count <span class="op">===</span> <span class="dv">7</span> ) <span class="op">{</span>
      subdivide_count <span class="op">=</span> <span class="dv">7</span><span class="op">;</span>
    <span class="op">}</span>  <span class="cf">else</span> <span class="op">{</span>
      subdivide_count <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span>
      <span class="va">document</span>.<span class="at">getElementById</span>( <span class="st">&quot;subdivision_text_box&quot;</span> ).<span class="at">innerHTML</span> <span class="op">=</span> <span class="st">&quot;Subdivision: &quot;</span> <span class="op">+</span> subdivide_count<span class="op">;</span>
      <span class="at">initBuffers</span>( )<span class="op">;</span>
    <span class="op">}</span>
  <span class="op">};</span>

<span class="co">// ...</span>

<span class="kw">function</span> <span class="at">divide_tetrahedron</span>( p1<span class="op">,</span> p2<span class="op">,</span> p3<span class="op">,</span> p4<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> c4<span class="op">,</span> count<span class="op">,</span> smooth ) <span class="op">{</span>
  <span class="co">// ...</span>

  <span class="cf">if</span> (count <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">{</span>
    <span class="at">divide_tetrahedron</span>( p1<span class="op">,</span>    p1_p2<span class="op">,</span> p1_p3<span class="op">,</span> p1_p4<span class="op">,</span> c1<span class="op">,</span>    c1_c2<span class="op">,</span> c1_c3<span class="op">,</span> c1_c4<span class="op">,</span> count <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> smooth )<span class="op">;</span>
    <span class="at">divide_tetrahedron</span>( p1_p2<span class="op">,</span> p2<span class="op">,</span>    p2_p3<span class="op">,</span> p2_p4<span class="op">,</span> c1_c2<span class="op">,</span> c2<span class="op">,</span>    c2_c3<span class="op">,</span> c2_c4<span class="op">,</span> count <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> smooth )<span class="op">;</span>
    <span class="at">divide_tetrahedron</span>( p1_p3<span class="op">,</span> p2_p3<span class="op">,</span> p3<span class="op">,</span>    p3_p4<span class="op">,</span> c1_c3<span class="op">,</span> c2_c3<span class="op">,</span> c3<span class="op">,</span>    c3_c4<span class="op">,</span> count <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> smooth )<span class="op">;</span>
    <span class="at">divide_tetrahedron</span>( p1_p4<span class="op">,</span> p2_p4<span class="op">,</span> p3_p4<span class="op">,</span> p4<span class="op">,</span>    c1_c4<span class="op">,</span> c2_c4<span class="op">,</span> c3_c4<span class="op">,</span> c4<span class="op">,</span>    count <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> smooth )<span class="op">;</span>
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    <span class="co">// No more subdivision, so assemble this tetrahedron/pyramid.</span>
    <span class="co">// The recursive base case.</span>

    <span class="at">tetrahedron</span>( p1<span class="op">,</span> p2<span class="op">,</span> p3<span class="op">,</span> p4<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> c4<span class="op">,</span> smooth )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span>

<span class="co">// ...</span>

<span class="at">divide_tetrahedron</span>(
  point_one<span class="op">,</span>
  point_two<span class="op">,</span>
  point_three<span class="op">,</span>
  point_four<span class="op">,</span>
  color_one<span class="op">,</span>
  color_two<span class="op">,</span>
  color_three<span class="op">,</span>
  color_four<span class="op">,</span>
  subdivide_count<span class="op">,</span>
  <span class="kw">false</span>
)<span class="op">;</span></code></pre></div>
<p>As we move up the stack of recursion, if we have completed all <code>count</code>s of subdivision, we’ll assemble the pyramid using the four new points and colors and then move back down the stack.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">tetrahedron</span>( p1<span class="op">,</span> p2<span class="op">,</span> p3<span class="op">,</span> p4<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> c4<span class="op">,</span> smooth ) <span class="op">{</span>
  <span class="kw">var</span> fN1 <span class="op">=</span> <span class="at">triangle</span>( p1<span class="op">,</span> p2<span class="op">,</span> p3<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> smooth )<span class="op">;</span> <span class="co">// Front face.</span>
  <span class="kw">var</span> fN2 <span class="op">=</span> <span class="at">triangle</span>( p1<span class="op">,</span> p4<span class="op">,</span> p2<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c4<span class="op">,</span> smooth )<span class="op">;</span> <span class="co">// Right face.</span>
  <span class="kw">var</span> fN3 <span class="op">=</span> <span class="at">triangle</span>( p1<span class="op">,</span> p3<span class="op">,</span> p4<span class="op">,</span> c1<span class="op">,</span> c3<span class="op">,</span> c4<span class="op">,</span> smooth )<span class="op">;</span> <span class="co">// Left face.</span>
  <span class="kw">var</span> fN4 <span class="op">=</span> <span class="at">triangle</span>( p2<span class="op">,</span> p4<span class="op">,</span> p3<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> c4<span class="op">,</span> smooth )<span class="op">;</span> <span class="co">// Bottom face.</span>

  <span class="co">// Compute and add the vertex normals using the face normals returned.</span>
  <span class="co">// These vertex normals will be used for the lighting calculations</span>
  <span class="co">// making for a smooth appearance.</span>

  <span class="cf">if</span> ( smooth <span class="op">===</span> <span class="kw">true</span> ) <span class="op">{</span>
    <span class="co">// Compute in counter-clockwise order since the vertices</span>
    <span class="co">// were added in counter-clockwise order.</span>

    <span class="at">weighted_vertex_normal</span>( p3<span class="op">,</span> fN1<span class="op">,</span> fN3<span class="op">,</span> fN4 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p2<span class="op">,</span> fN1<span class="op">,</span> fN4<span class="op">,</span> fN2 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p1<span class="op">,</span> fN1<span class="op">,</span> fN2<span class="op">,</span> fN3 )<span class="op">;</span>

    <span class="at">weighted_vertex_normal</span>( p2<span class="op">,</span> fN1<span class="op">,</span> fN4<span class="op">,</span> fN2 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p4<span class="op">,</span> fN2<span class="op">,</span> fN4<span class="op">,</span> fN3 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p1<span class="op">,</span> fN1<span class="op">,</span> fN2<span class="op">,</span> fN3 )<span class="op">;</span>

    <span class="at">weighted_vertex_normal</span>( p4<span class="op">,</span> fN2<span class="op">,</span> fN4<span class="op">,</span> fN3 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p3<span class="op">,</span> fN1<span class="op">,</span> fN3<span class="op">,</span> fN4 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p1<span class="op">,</span> fN1<span class="op">,</span> fN2<span class="op">,</span> fN3 )<span class="op">;</span>

    <span class="at">weighted_vertex_normal</span>( p3<span class="op">,</span> fN1<span class="op">,</span> fN3<span class="op">,</span> fN4 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p4<span class="op">,</span> fN2<span class="op">,</span> fN4<span class="op">,</span> fN3 )<span class="op">;</span>
    <span class="at">weighted_vertex_normal</span>( p2<span class="op">,</span> fN1<span class="op">,</span> fN4<span class="op">,</span> fN2 )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>It is in the <code>triangle</code> function that we build up the pyramid buffers getting them ready to be shipped off to the GPU.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">triangle</span>( p1<span class="op">,</span> p2<span class="op">,</span> p3<span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> c3<span class="op">,</span> smooth ) <span class="op">{</span>
  <span class="co">// Push the vertices to this triangle in counter-clockwise order.</span>
  <span class="co">//</span>
  <span class="co">//    1.....4</span>
  <span class="co">//   . .   . .</span>
  <span class="co">//  .   . .   .</span>
  <span class="co">// 3.....2.....5</span>
  <span class="co">//</span>
  <span class="co">// 1 then 2 then 3 would be clockwise order.</span>
  <span class="co">// 3 then 2 then 1 would be counter-closewise order.</span>

  <span class="co">// WebGL default for the front of the face of the triangle is counter-clockwise order.</span>
  <span class="co">// Thus push 3, 2, and then 1 in that order.</span>

  <span class="va">vertices</span>.<span class="at">push</span>( p3[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p3[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p3[ <span class="dv">2</span> ] )<span class="op">;</span>
  <span class="va">vertices</span>.<span class="at">push</span>( p2[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p2[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p2[ <span class="dv">2</span> ] )<span class="op">;</span>
  <span class="va">vertices</span>.<span class="at">push</span>( p1[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p1[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertices</span>.<span class="at">push</span>( p1[ <span class="dv">2</span> ] )<span class="op">;</span>

  <span class="co">// Push the vertex colors for this triangle face.</span>

  <span class="va">vertex_colors</span>.<span class="at">push</span>( c3[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c3[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c3[ <span class="dv">2</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( <span class="fl">1.0</span> )<span class="op">;</span>
  <span class="va">vertex_colors</span>.<span class="at">push</span>( c2[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c2[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c2[ <span class="dv">2</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( <span class="fl">1.0</span> )<span class="op">;</span>
  <span class="va">vertex_colors</span>.<span class="at">push</span>( c1[ <span class="dv">0</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c1[ <span class="dv">1</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( c1[ <span class="dv">2</span> ] )<span class="op">;</span> <span class="va">vertex_colors</span>.<span class="at">push</span>( <span class="fl">1.0</span> )<span class="op">;</span>

  <span class="co">// Compute this triangle face's face normal for use in the lighting calculations.</span>

  <span class="kw">var</span> triangle_side_u <span class="op">=</span> [ p2[ <span class="dv">0</span> ] <span class="op">-</span> p1[ <span class="dv">0</span> ]<span class="op">,</span> p2[ <span class="dv">1</span> ] <span class="op">-</span> p1[ <span class="dv">1</span> ]<span class="op">,</span> p2[ <span class="dv">2</span> ] <span class="op">-</span> p1[ <span class="dv">2</span> ] ]<span class="op">;</span>
  <span class="kw">var</span> triangle_side_v <span class="op">=</span> [ p3[ <span class="dv">0</span> ] <span class="op">-</span> p1[ <span class="dv">0</span> ]<span class="op">,</span> p3[ <span class="dv">1</span> ] <span class="op">-</span> p1[ <span class="dv">1</span> ]<span class="op">,</span> p3[ <span class="dv">2</span> ] <span class="op">-</span> p1[ <span class="dv">2</span> ] ]<span class="op">;</span>

  <span class="co">// Cross product N = U x V where U = &lt;x1,y1,z1&gt; and V = &lt;x2,y2,z2&gt;.</span>

  <span class="co">// Nx = ( z1 * y2 ) - ( y1 * z2 )</span>
  <span class="co">// Ny = ( x1 * z2 ) - ( z1 * x2 )</span>
  <span class="co">// Nz = ( y1 * x2 ) - ( x1 * y2 )</span>

  <span class="kw">var</span> face_normal_x <span class="op">=</span> ( triangle_side_u[ <span class="dv">2</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">1</span> ] ) <span class="op">-</span> ( triangle_side_u[ <span class="dv">1</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">2</span> ] )<span class="op">;</span>
  <span class="kw">var</span> face_normal_y <span class="op">=</span> ( triangle_side_u[ <span class="dv">0</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">2</span> ] ) <span class="op">-</span> ( triangle_side_u[ <span class="dv">2</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">0</span> ] )<span class="op">;</span>
  <span class="kw">var</span> face_normal_z <span class="op">=</span> ( triangle_side_u[ <span class="dv">1</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">0</span> ] ) <span class="op">-</span> ( triangle_side_u[ <span class="dv">0</span> ] <span class="op">*</span> triangle_side_v[ <span class="dv">1</span> ] )<span class="op">;</span>

  <span class="kw">var</span> length <span class="op">=</span> <span class="va">Math</span>.<span class="at">sqrt</span>( ( face_normal_x <span class="op">*</span> face_normal_x ) <span class="op">+</span> ( face_normal_y <span class="op">*</span> face_normal_y ) <span class="op">+</span> ( face_normal_z <span class="op">*</span> face_normal_z ) )<span class="op">;</span>

  <span class="co">// Normalize this face normal.</span>

  <span class="cf">if</span> ( length <span class="op">!=</span> <span class="fl">0.0</span> ) <span class="op">{</span>
    face_normal_x <span class="op">=</span> face_normal_x / length<span class="op">;</span>
    face_normal_y <span class="op">=</span> face_normal_y / length<span class="op">;</span>
    face_normal_z <span class="op">=</span> face_normal_z / length<span class="op">;</span>
  <span class="op">}</span>

  <span class="co">// Use the face normal of this triangle face as the vertex normal for all of the vertex normals</span>
  <span class="co">// that make up this triangle face. These vertex normals will be used in the lighting calculations.</span>
  <span class="co">// Instead, to compute the vertex normals, you could average all of the face normals that are adjacent</span>
  <span class="co">// to a particular vertex as the vertex normal. This would provide a smooth surface appearance.</span>

  <span class="cf">if</span> ( smooth <span class="op">===</span> <span class="kw">false</span> ) <span class="op">{</span>
    <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_x )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_y )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_z )<span class="op">;</span>
    <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_x )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_y )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_z )<span class="op">;</span>
    <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_x )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_y )<span class="op">;</span> <span class="va">vertex_normals</span>.<span class="at">push</span>( face_normal_z )<span class="op">;</span>
  <span class="op">}</span>

  <span class="co">// Return the face normal to later compute the average of all the face normals that are adjacent to a particular vertex.</span>

  <span class="cf">return</span> [ face_normal_x<span class="op">,</span> face_normal_y<span class="op">,</span> face_normal_z ]<span class="op">;</span>
<span class="op">}</span></code></pre></div>
<p>To recap, we start with one pyramid. We then subdivide it into 4, 16, 64, …, 4<sup>count</sup> pyramids based on the user’s selected subdivision amount <code>&gt; 0</code>. Once <code>count</code> is <code>0</code>, the recursion is complete and we then push the new vertices, colors, and normals to their appropriate buffers.</p>
<h1 id="camera-system">Camera System</h1>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/camera_four_view.png" alt="Camera system with up, side and direction vectors." class="post-img post-img-fill" />
<p class="caption">Camera system with up, side and direction vectors.</p>
</div>
<p>Below are the system globals pertaining to the camera system. The camera is defined by four vectors: position, direction, up and sideways. The original direction vector is used to reset the calculations before performing pitch and yaw. <code>camera_keys</code> hold the current state of what keys are being pressed for the translation calculations. <code>camera_pitch</code> involves the up and down angle of rotation while <code>camera_yaw</code> involves the side-to-side angle rotation.</p>
<center>
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/pitch.gif" class="post-img post-img-limit" /> <img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/yaw.gif" class="post-img post-img-limit" />
</center>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Camera controls.</span>

<span class="kw">var</span> use_controls <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>

<span class="kw">var</span> camera_position_vector           <span class="op">=</span> <span class="va">vec3</span>.<span class="at">set</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="fl">0.9</span><span class="op">,</span> <span class="dv">0</span> )<span class="op">;</span>
<span class="kw">var</span> original_camera_direction_vector <span class="op">=</span> <span class="va">vec3</span>.<span class="at">set</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="dv">1</span><span class="op">,</span>   <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span> )<span class="op">;</span>
<span class="kw">var</span> camera_up_vector                 <span class="op">=</span> <span class="va">vec3</span>.<span class="at">set</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="dv">0</span><span class="op">,</span>   <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span> )<span class="op">;</span>

<span class="kw">var</span> camera_direction_vector          <span class="op">=</span> <span class="va">vec3</span>.<span class="at">clone</span>( original_camera_direction_vector )<span class="op">;</span>
<span class="kw">var</span> camera_sideways_vector           <span class="op">=</span> <span class="va">vec3</span>.<span class="at">cross</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> camera_direction_vector<span class="op">,</span> camera_up_vector )<span class="op">;</span>

<span class="kw">var</span> camera_pitch <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span>
<span class="kw">var</span> camera_yaw   <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span>

<span class="co">//        W,    S,    A,     D</span>
<span class="co">//  Forward, Back, Left, Right</span>
<span class="co">// Index: 0     1     2      3</span>

<span class="kw">var</span> camera_keys <span class="op">=</span> [ <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span> ]<span class="op">;</span></code></pre></div>
<p>Unlike native applications, we will need to acquire a lock on the mouse pointer.</p>
<blockquote>
<p>The Pointer Lock API (formerly called Mouse Lock API) provides input methods based on the movement of the mouse over time (i.e., deltas), not just the absolute position of the mouse cursor in the viewport. It gives you access to raw mouse movement, locks the target of mouse events to a single element, eliminates limits on how far mouse movement can go in a single direction, and removes the cursor from view. It is ideal for first person 3D games, for example.</p>
<footer>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">Pointer Lock API, Mozilla Developer Network</a>
</footer>
</blockquote>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// The following is for locking the mouse pointer if possible.</span>
<span class="co">// The mouse pointer lock API is not available in all browsers.</span>

<span class="kw">function</span> <span class="at">pointer_lock_change</span>( )
<span class="op">{</span>
  <span class="cf">if</span> ( <span class="va">document</span>.<span class="at">pointerLockElement</span>       <span class="op">===</span> canvas <span class="op">||</span>
       <span class="va">document</span>.<span class="at">mozPointerLockElement</span>    <span class="op">===</span> canvas <span class="op">||</span>
       <span class="va">document</span>.<span class="at">webkitPointerLockElement</span> <span class="op">===</span> canvas    ) <span class="op">{</span>
    acquired_pointer_lock <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>
  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>
    acquired_pointer_lock <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Changing the camera based on immediate mouse events makes for a jittery experience. We’ll collect up the individual mouse movements and take the average come time to change the camera. This makes for a smooth experience.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Gather up the changes in the mouse-x and mouse-y dimensions when the user moves the mouse.</span>

<span class="kw">function</span> <span class="at">mouse_move</span>( event ) <span class="op">{</span>
  <span class="cf">if</span> ( <span class="op">!</span>acquired_pointer_lock ) <span class="op">{</span>
    <span class="kw">var</span> mouse_x_delta <span class="op">=</span> <span class="va">event</span>.<span class="at">clientX</span> <span class="op">-</span> previous_mouse_coordinates[ <span class="dv">0</span> ]<span class="op">;</span>
    <span class="kw">var</span> mouse_y_delta <span class="op">=</span> <span class="va">event</span>.<span class="at">clientY</span> <span class="op">-</span> previous_mouse_coordinates[ <span class="dv">1</span> ]<span class="op">;</span>

    previous_mouse_coordinates[ <span class="dv">0</span> ] <span class="op">=</span> <span class="va">event</span>.<span class="at">clientX</span><span class="op">;</span>
    previous_mouse_coordinates[ <span class="dv">1</span> ] <span class="op">=</span> <span class="va">event</span>.<span class="at">clientY</span><span class="op">;</span>

    <span class="cf">if</span> ( <span class="va">mouse_x_deltas</span>.<span class="at">length</span> <span class="op">&lt;=</span> max_mouse_x_deltas ) <span class="va">mouse_x_deltas</span>.<span class="at">push</span>( mouse_x_delta )<span class="op">;</span>
    <span class="cf">if</span> ( <span class="va">mouse_y_deltas</span>.<span class="at">length</span> <span class="op">&lt;=</span> max_mouse_y_deltas ) <span class="va">mouse_y_deltas</span>.<span class="at">push</span>( mouse_y_delta )<span class="op">;</span>
  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> ( acquired_pointer_lock ) <span class="op">{</span>
    <span class="kw">var</span> mouse_x_delta <span class="op">=</span> <span class="va">event</span>.<span class="at">movementX</span>       <span class="op">||</span>
                        <span class="va">event</span>.<span class="at">mozMovementX</span>    <span class="op">||</span>
                        <span class="va">event</span>.<span class="at">webkitMovementX</span> <span class="op">||</span>
                        <span class="dv">0</span><span class="op">;</span>

    <span class="kw">var</span> mouse_y_delta <span class="op">=</span> <span class="va">event</span>.<span class="at">movementY</span>       <span class="op">||</span>
                        <span class="va">event</span>.<span class="at">mozMovementY</span>    <span class="op">||</span>
                        <span class="va">event</span>.<span class="at">webkitMovementY</span> <span class="op">||</span>
                        <span class="dv">0</span><span class="op">;</span>

    previous_mouse_coordinates[ <span class="dv">0</span> ] <span class="op">=</span> <span class="va">event</span>.<span class="at">clientX</span> <span class="op">-</span> mouse_x_delta<span class="op">;</span>
    previous_mouse_coordinates[ <span class="dv">1</span> ] <span class="op">=</span> <span class="va">event</span>.<span class="at">clientY</span> <span class="op">-</span> mouse_y_delta<span class="op">;</span>

    <span class="cf">if</span> ( <span class="va">mouse_x_deltas</span>.<span class="at">length</span> <span class="op">&lt;=</span> max_mouse_x_deltas ) <span class="va">mouse_x_deltas</span>.<span class="at">push</span>( mouse_x_delta )<span class="op">;</span>
    <span class="cf">if</span> ( <span class="va">mouse_y_deltas</span>.<span class="at">length</span> <span class="op">&lt;=</span> max_mouse_y_deltas ) <span class="va">mouse_y_deltas</span>.<span class="at">push</span>( mouse_y_delta )<span class="op">;</span>
  <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>To calculate the yaw and pitch angles, we’ll first average the changes in the mouse movements. We will treat this average as a scalar or “degrees” and convert to radians. The <code>0.35</code> constant was found through trial-and-error and serves to dampen the rotation. Next, we’ll wrap these values after 360 degrees. For example, 450 degrees becomes 90 degrees. So that they cannot completely rotate the pitch around, we’ll limit the pitch angle to <code>!(45 &lt; x &lt; 315)</code> or <code>0 &lt;= x &lt;= 45</code> and <code>315 &lt;= x &lt;= 360</code>. Last, we will remove the first elements from the mouse movement differences. This will keep a stable window as we compute the moving average.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Calculate the camera yaw and pitch angles.</span>

camera_yaw    <span class="op">+=</span> <span class="op">-</span>( <span class="at">get_average</span>( mouse_x_deltas ) <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="fl">180.0</span> ) ) <span class="op">*</span> <span class="fl">0.35</span><span class="op">;</span>
camera_pitch  <span class="op">+=</span> <span class="op">-</span>( <span class="at">get_average</span>( mouse_y_deltas ) <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="fl">180.0</span> ) ) <span class="op">*</span> <span class="fl">0.35</span><span class="op">;</span>

<span class="co">// Wrap the angles.</span>

camera_yaw   <span class="op">=</span> <span class="at">get_remainder</span>( camera_yaw<span class="op">,</span>   <span class="va">Math</span>.<span class="at">PI</span> <span class="op">*</span> <span class="dv">2</span> )<span class="op">;</span>
camera_pitch <span class="op">=</span> <span class="at">get_remainder</span>( camera_pitch<span class="op">,</span> <span class="va">Math</span>.<span class="at">PI</span> <span class="op">*</span> <span class="dv">2</span> )<span class="op">;</span>

<span class="co">// Limit the pitch angle.</span>

<span class="cf">if</span> ( camera_pitch <span class="op">&lt;=</span> ( <span class="dv">180</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> ) ) <span class="op">&amp;&amp;</span> camera_pitch <span class="op">&gt;=</span> ( <span class="dv">45</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> ) ) ) <span class="op">{</span>
  camera_pitch <span class="op">=</span> <span class="dv">45</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="cf">if</span> ( camera_pitch <span class="op">&lt;=</span> ( <span class="dv">315</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> ) ) <span class="op">&amp;&amp;</span> camera_pitch <span class="op">&gt;</span> ( <span class="dv">180</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> ) ) ) <span class="op">{</span>
  camera_pitch <span class="op">=</span> <span class="dv">315</span> <span class="op">*</span> ( <span class="va">Math</span>.<span class="at">PI</span> / <span class="dv">180</span> )<span class="op">;</span>
<span class="op">}</span>

<span class="co">// Remove the first elements from the mouse delta buffers.</span>

<span class="va">mouse_x_deltas</span>.<span class="at">shift</span>( )<span class="op">;</span>
<span class="va">mouse_y_deltas</span>.<span class="at">shift</span>( )<span class="op">;</span></code></pre></div>
<p>With the angles ready, we will first perform yaw. We rotate the <code>original_camera_direction_vector</code> by the yaw angle with the result being the <code>camera_direction_vector</code>. Before performing pitch, we normalize the <code>camera_direction_vector</code> making it a unit vector pointing in the same direction as it was pointing before normalization. Taking the <a href="https://en.wikipedia.org/wiki/Cross_product">cross product</a> of the <code>camera_direction_vector</code> and the <code>camera_up_vector</code> yields us our <code>camera_sideways_vector</code>. Now we rotate the <code>camera_direction_vector</code> by the pitch angle using the <code>camera_sideways_vector</code>. Imagine holding the <code>camera_sideways_vector</code> as you would a motorcycle throttle. Rolling back or forth on the throttle pitches the camera up or down.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Perform yaw.</span>

<span class="va">vec3</span>.<span class="at">transformMat4</span>(
  camera_direction_vector<span class="op">,</span>
  original_camera_direction_vector<span class="op">,</span>
  <span class="va">mat4</span>.<span class="at">rotate</span>( <span class="va">mat4</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="va">mat4</span>.<span class="at">identity</span>( <span class="va">mat4</span>.<span class="at">create</span>( ) )<span class="op">,</span> camera_yaw<span class="op">,</span> camera_up_vector )
)<span class="op">;</span>

camera_direction_vector <span class="op">=</span> <span class="va">vec3</span>.<span class="at">normalize</span>( camera_direction_vector<span class="op">,</span> camera_direction_vector )<span class="op">;</span>

<span class="co">// Perform pitch.</span>

camera_sideways_vector <span class="op">=</span> <span class="va">vec3</span>.<span class="at">cross</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> camera_direction_vector<span class="op">,</span> camera_up_vector )<span class="op">;</span>

<span class="va">vec3</span>.<span class="at">transformMat4</span>(
  camera_direction_vector<span class="op">,</span>
  camera_direction_vector<span class="op">,</span>
  <span class="va">mat4</span>.<span class="at">rotate</span>( <span class="va">mat4</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="va">mat4</span>.<span class="at">identity</span>( <span class="va">mat4</span>.<span class="at">create</span>( ) )<span class="op">,</span> camera_pitch<span class="op">,</span> camera_sideways_vector )
)<span class="op">;</span>

camera_direction_vector <span class="op">=</span> <span class="va">vec3</span>.<span class="at">normalize</span>( camera_direction_vector<span class="op">,</span> camera_direction_vector )<span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/camera_vectors.png" alt="Camera vectors. Red sideways, blue direction, green up and yellow position." class="post-img post-img-fill" />
<p class="caption">Camera vectors. Red sideways, blue direction, green up and yellow position.</p>
</div>
<h1 id="lighting-system">Lighting System</h1>
<p>For a more realistic scene, we will use per fragment lighting. Stated earlier, we need to acquire the ambient, location, and color fragment shader variable indexes for our single point light in our scene. Our lighting model will be the <a href="https://en.wikipedia.org/wiki/Phong_reflection_model">Phong Reflection Model</a>.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">shaderProgram</span>.<span class="at">ambientColorUniform</span>       <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uAmbientColor&quot;</span>       )<span class="op">;</span>
<span class="va">shaderProgram</span>.<span class="at">pointLightLocationUniform</span> <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uPointLightLocation&quot;</span> )<span class="op">;</span>
<span class="va">shaderProgram</span>.<span class="at">pointLightColorUniform</span>    <span class="op">=</span> <span class="va">gl</span>.<span class="at">getUniformLocation</span>( shaderProgram<span class="op">,</span> <span class="st">&quot;uPointLightColor&quot;</span>    )<span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/point_light_in_scene.png" alt="Point light illuminating the Sierpinski Pyramids." class="post-img post-img-fill" />
<p class="caption">Point light illuminating the Sierpinski Pyramids.</p>
</div>
<p>With the indexes in hand, we can pass the needed information to the fragment shader.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Translate the light's position based on the view matrix.</span>

<span class="kw">var</span> light_position_vector <span class="op">=</span> <span class="va">vec3</span>.<span class="at">set</span>( <span class="va">vec3</span>.<span class="at">create</span>( )<span class="op">,</span> <span class="op">-</span><span class="fl">4.2</span><span class="op">,</span> <span class="fl">1.0</span><span class="op">,</span> <span class="fl">0.0</span> )<span class="op">;</span>
<span class="va">vec3</span>.<span class="at">transformMat4</span>( light_position_vector<span class="op">,</span> light_position_vector<span class="op">,</span> view_matrix )<span class="op">;</span>

<span class="co">// Pass the shaders the light information.</span>

<span class="va">gl</span>.<span class="at">uniform3f</span>( <span class="va">shaderProgram</span>.<span class="at">ambientColorUniform</span><span class="op">,</span>        <span class="fl">0.1</span><span class="op">,</span> <span class="fl">0.1</span><span class="op">,</span>  <span class="fl">0.1</span> )<span class="op">;</span>

<span class="va">gl</span>.<span class="at">uniform3f</span>(
  <span class="va">shaderProgram</span>.<span class="at">pointLightLocationUniform</span><span class="op">,</span>
  light_position_vector[ <span class="dv">0</span> ]<span class="op">,</span>
  light_position_vector[ <span class="dv">1</span> ]<span class="op">,</span>
  light_position_vector[ <span class="dv">2</span> ]
)<span class="op">;</span>

<span class="va">gl</span>.<span class="at">uniform3f</span>( <span class="va">shaderProgram</span>.<span class="at">pointLightColorUniform</span><span class="op">,</span>     <span class="fl">9.0</span><span class="op">,</span> <span class="fl">9.0</span><span class="op">,</span>  <span class="fl">3.0</span> )<span class="op">;</span></code></pre></div>
<p>All of the lighting calculations take place in the fragment shader.</p>
<p>Let us get the boilerplate out of the way.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// Fragment shader GLSL code.</span>

<span class="kw">var</span> fragment_shader <span class="op">=</span> <span class="va">document</span>.<span class="at">createElement</span>( <span class="st">&quot;script&quot;</span> )<span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">id</span> <span class="op">=</span> <span class="st">&quot;shader-fs&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">type</span> <span class="op">=</span> <span class="st">&quot;x-shader/x-fragment&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>   <span class="op">=</span> <span class="st">&quot;precision mediump float;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;uniform vec3 uAmbientColor;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;uniform vec3 uPointLightLocation;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;uniform vec3 uPointLightColor;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;varying vec3 vTransformedNormal;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;varying vec4 vPosition;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;varying vec4 vDiffuseColor;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;void main( void ) {&quot;</span><span class="op">;</span></code></pre></div>
<p>We will need the light and eye direction vectors that point to the point light and camera respectively.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 light_direction  =  normalize( uPointLightLocation - vPosition.xyz );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 eye_direction    = -normalize( vPosition.xyz );&quot;</span><span class="op">;</span></code></pre></div>
<p>The surface normal is needed and depending on the fragments orientation, we will need to either negate or not negate the normalized surface vector.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// WebGL default for the front of the face of the triangle is counter-clockwise order.</span>

<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 surface_normal;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   if ( gl_FrontFacing ) {&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;        surface_normal =  normalize( vTransformedNormal );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   }&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   else {&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;        surface_normal = -normalize( vTransformedNormal );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   }&quot;</span><span class="op">;</span></code></pre></div>
<p>The intensity of the light for this fragment is the <code>max</code> of either the dot product between the surface normal and light direction or zero. If the light direction vector completely <i>shadows</i> the surface normal, the intensity will be at its brightest. Instead of it being the same intensity all over we will attenuate based on a constant outer and inner radius as well as the distance from the fragment to the light source. The attenuation will create a gradient of intensity as you move from the inner radius to the outer radius.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float light_intensity =  max( dot( surface_normal, light_direction ), 0.0 );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float light_outer_radius = 5.0;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float light_inner_radius = 0.0;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float light_distance  = length( vPosition.xyz - uPointLightLocation );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float attenuation     = 1.0 - smoothstep( light_inner_radius, light_outer_radius, light_distance );&quot;</span><span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/surface_normal.png" alt="Surface normal versus the light direction vector. Outer versus inner radius." class="post-img post-img-fill" />
<p class="caption">Surface normal versus the light direction vector. Outer versus inner radius.</p>
</div>
<p>With the scalars defined, we can now calculate the ambient, diffuse and specular lights. The ambient color is the easiest as it is the surface color times the default color for any surface regardless of a light source. The diffuse color is the surface color times the color of the light times the light intensity. If the <code>light_intensity &gt; 0</code>, we calculate the specular highlight based on the dot product between the reflection of the light direction about the surface normal and the eye direction vector. We then raise this scalar product to the power of 50. All of this is then colored by the color of the point light. The specular highlight is the most intense when the reflection is in the same direction as the eye. Finishing the lighting model, we set the final color to be the sum of the ambient, diffuse and specular colors.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 ambient       = vDiffuseColor.rgb * uAmbientColor;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 diffuse       = vDiffuseColor.rgb * uPointLightColor * light_intensity;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec3 specular      = vec3( 0.0, 0.0, 0.0 );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   if ( light_intensity &gt; 0.0 )&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;     specular         = uPointLightColor * pow( max( dot( reflect( -light_direction, surface_normal ), eye_direction ), 0.0 ), 50.0 );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   diffuse            = attenuation * diffuse;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   specular           = attenuation * specular;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec4 final_color   = vec4( ambient + diffuse + specular, 1.0 );&quot;</span><span class="op">;</span></code></pre></div>
<p>We could almost stop here but we will add attenuated fog for even more realism. As the distance from the camera to the fragment increases, so does the fog factor. Picture standing on a misty road during the night with a street lamp. As you look out in the distance, the light fades and the mist takes over.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float fog_coord    = ( gl_FragCoord.z / gl_FragCoord.w ) / 500.0;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float fog_density  = 50.0;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float fog          = fog_coord * fog_density;&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   vec4  fog_color    = vec4( 0.1, 0.1, 0.1, 1.0 );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   float fog_factor   = clamp( 1.0 - fog, 0.0, 1.0 );&quot;</span><span class="op">;</span></code></pre></div>
<div class="figure">
<img src="../images/2016-02-29-triforce-overload-sierpinski-pyramids/fog.png" alt="The fog eventually encompassing the pyramid." class="post-img post-img-fill" />
<p class="caption">The fog eventually encompassing the pyramid.</p>
</div>
<p>We complete the lighting system with the calculation of the fragment color. Depending on the <code>fog_factor</code>, the fragment color could be the final color, a mixture of the final color and the fog color, or the fog color completely.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;   gl_FragColor = mix( fog_color, final_color, vec4( fog_factor, fog_factor, fog_factor, fog_factor ) );&quot;</span><span class="op">;</span>
<span class="va">fragment_shader</span>.<span class="at">innerHTML</span>  <span class="op">+=</span> <span class="st">&quot;}&quot;</span><span class="op">;</span></code></pre></div>
<h1 id="wrap-up">Wrap-up</h1>
<p>We defined the HTML canvas and WebGL context. The shaders were loaded and indexes to their variables were gathered. Camera controls were defined and event handling was set in place. The user can pitch and yaw the camera allowing them to look around the scene. Per frame, we rendered the Sierpinski Pyramids subdivided based on the user’s selection. For added realism, we used the Phong Reflection Model for lighting and employed attenuated fog.</p>
<p>If this project interested you, be sure to take a look at <a href="https://github.com/lettier/isosurface">Isosurface extraction using Marching Cubes and pure WebGL</a>.</p>
</div>
<div class="post-footer">
  <div class="display-left">
    <h2 class="post-footer-cta">
      Don't miss out&mdash;click <a href="../posts.html" title="posts">posts</a> or
      subscribe via <a href="../rss.xml" type="application/rss+xml" target="_blank" title="RSS">RSS</a> for more content.
      <!--Return to the <a href="#top" title="top">top</a>.-->
    </h2>
  </div>
  <div class="display-right text-align-right post-footer-copyright">
    <h4>
      <i class="fa fa-copyright"></i> <span id="copyrightYear">2015</span> David Lettier.
    </h4>
  </div>
</div>
<script>
  (function () {
    document.getElementById('copyrightYear').innerHTML = new Date().getFullYear();
  })();
</script>

    </div>
    <div class="share-toolbox addthis_sharing_toolbox"></div>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-4fc2bc7a00a9352b"></script>
    <script>
      (function(i,s,o,g,r,a,m){
        i.GoogleAnalyticsObject = r;
        i[r] = i[r] || function () { (i[r].q = i[r].q || []).push(arguments); };
        i[r].l=1*new Date();
        a=s.createElement(o);
        m=s.getElementsByTagName(o)[0];
        a.async=1;
        a.src=g;
        m.parentNode.insertBefore(a,m);
      })(
        window,
        document,
        'script',
        '//www.google-analytics.com/analytics.js',
        'ga'
      );
      ga('create', 'UA-34323684-2', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
